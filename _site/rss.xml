<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>yuandaima</title>
        <description>yuandaima - yuandaima</description>
        <link>http://yuxiaole.github.io/jekyll</link>
        <link>http://yuxiaole.github.io/jekyll</link>
        <lastBuildDate>2015-05-13T08:16:56-07:00</lastBuildDate>
        <pubDate>2015-05-13T08:16:56-07:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>前端工程师</title>
                <description>&lt;h1&gt;为什么整个互联网行业都缺前端工程师？&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;&lt;p&gt;现在，几乎整个互联网行业都缺前端工程师，不仅在刚起步的创业公司，上市公司乃至巨头，这个问题也一样存在。没错，优秀的前端工程师简直比大熊猫还稀少。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;每天，100offer的HR群都有人在吐槽招不到前端工程师。实话说对这些需求，Betty也无能为力，因为在供不应求的前端招聘市场上，优秀的前端工程师才是有话语权的那一方。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;放眼全球，不仅在国内的互联网行业，在国外，前端工程师一样是需求旺盛、供不应求的香饽饽。&lt;/p&gt;

&lt;p&gt;举个例子，根据indeed.com抓取的数千家网站的职位显示：目前前端的热门岗位——「HTML5」是需求增长最快的开发岗位，在所有开发职位中排名第一，MongoDB和iOS紧随其后位列第二、第三。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-a0bf3e9e1ae8ad23.png?imageView2/2/w/1240/q/100&quot; alt=&quot;web&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可见，HTML5可以说是最热门的前端岗位了，在2010年和2014年底有两次爆发性增长，现在在美国的岗位需求甚至超过了iOS。&lt;/p&gt;

&lt;p&gt;所以市场上优秀的前端工程师相对较缺少，是一个世界性难题。&lt;/p&gt;

&lt;h3&gt;原因一：前端相对来说是一个新领域，当今的web需求要求更多的工程师供应&lt;/h3&gt;

&lt;p&gt;可能很多人认为前端开发和web开发类似，而web开发已经有20多年的历史，所以前端并不是一个新领域。然而，前端工程师的概念中的「接口技术实现和用户体验作为一个专业的工作领域」，却无疑是很新的。大概几年前，前端开发的技术增长迅猛，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-d3c95d559aa5004a.png?imageView2/2/w/1240/q/100&quot; alt=&quot;new&quot; /&gt;&lt;/p&gt;

&lt;p&gt;15年或更久以前，web的可视化设计和技术实现所需要的资源是平均分配的。随着网站的发展——网站不仅是一个登录页面，工程资源的需求越来越明显。人们开始专门学习网站专用的JS、后端技术、UX、数据库，甚至系统设计。&lt;/p&gt;

&lt;p&gt;今天，一个像AirBnB/Facebook/Quora的Web应用程序，投入的工程资源比设计资源多得多。换句话说，如今，做出网页的视觉设计比技术实现要更快，所以当今的web需求要求更多的工程师供应。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-29a474c12e5f2f35.jpg?imageView2/2/w/1240/q/100&quot; alt=&quot;engineer&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;现在，一位合格的前端工程师，必须对视觉设计有兴趣（或者乐于做一个受虐狂▼）。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-85dddc7874142e8a.jpg?imageView2/2/w/1240/q/100&quot; alt=&quot;game&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;很显然，要处理大量的Web应用程序需求，技术任务就要进行分类，以便于多人同时处理网站请求。事实上现在已经不可能一个人快速地解决所有的技术细节了。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-9ef8899b4ce9433c.jpg&quot; alt=&quot;reason&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在还有一类人是独自处理一个Web应用程序的所有问题，即「全栈工程师」，但是优秀的全栈工程师同样如大熊猫一般数量稀少。&lt;/p&gt;

&lt;p&gt;现在，一个创业公司想要成功，几乎要覆盖一个Web应用程序的诸多技术方面：前端、后台、DBA、运营等。虽然已经有一些服务可以让企业购买登陆页面的前端模块和组件；但是如果你想要创造一些真正的Web应用程序，除了求助前端工程师，别无他法，就像你要创立一个品牌你也绕不开请一位设计师一样。&lt;/p&gt;

&lt;h3&gt;原因二：对前端，普遍存在巨大的误解，其实前端一点也不简单&lt;/h3&gt;

&lt;p&gt;大多人都认为前端开发是一个「相对于其他模块来说更简单的领域」，在他们心中的前端工程师是这样工作的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、把Photoshop文件、图片或者线框做成一个页面；&lt;/p&gt;

&lt;p&gt;2、偶尔设计Photoshop文件、图片或者线框；&lt;/p&gt;

&lt;p&gt;3、用JS实现动画、过渡效果；&lt;/p&gt;

&lt;p&gt;4、用HTML和CSS编程，实现网页的内容和形式。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;事实上，前端工程师在做的是：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、在设计师和工程师之间创建可视化的语言；&lt;/p&gt;

&lt;p&gt;2、根据设计稿定义一组代表内容、品牌和功能的组件；&lt;/p&gt;

&lt;p&gt;3、为Web应用程序的框架、需求、可视化的语言和规格设定基准；&lt;/p&gt;

&lt;p&gt;4、根据设备、浏览器、屏幕、动画来划分web应用的工作划分；&lt;/p&gt;

&lt;p&gt;5、用QA基准来保证指南来确保品牌忠诚度、代码质量、产品标准；&lt;/p&gt;

&lt;p&gt;6、调节Web应用程序的样式，包括间距、字体、标题、图标、布局等等；&lt;/p&gt;

&lt;p&gt;7、根据不同分辨率、横屏竖屏等，调节Web应用程序的样式；&lt;/p&gt;

&lt;p&gt;8、标记 Web 应用程序，使之语义化，SEO 友好；&lt;/p&gt;

&lt;p&gt;9、通过API获取内容要考虑友好性、电池消耗性、设备和客户端的特性；&lt;/p&gt;

&lt;p&gt;10、开发客户端要考虑动画的流畅、延迟加载、交互、应用工作流程，大多数时间用来考虑渐进增强和向后兼容的标准；&lt;/p&gt;

&lt;p&gt;11、保证后台连接安全，采取跨地资源共享（ CORS ）的程序考虑，防止跨站点脚本（ XSS）和跨站点请求伪造（ CSRF ） ；&lt;/p&gt;

&lt;p&gt;12、最重要的是，尽管有严格的期限、利益相关者的要求，以及设备的限制，无论现在还是将来永远是「客户第一」。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;为了实现上述目标，前端工程师采用了从可视化到编程的多种工具 ，甚至有时要照顾市场、 UX 到内容tweakes等等。&lt;/p&gt;

&lt;h3&gt;原因三：大量糟糕前端工程师的存在，扰乱了市场&lt;/h3&gt;

&lt;p&gt;这或许是难以招到优秀前端工程师最明显的原因。由于前端工程师的入门门槛非常低，JS、CSS、HTML并不是很难入门掌握的语言，似乎只要花一点时间，谁都可以通过网上教程和书本学会它。对的，前端工程师市场就是被这些浅尝辄止的家伙搞坏的。&lt;/p&gt;

&lt;p&gt;糟糕的前端工程师是这样做事的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、滥用 JavaScript 库，因为他们实际上并不了 JavaScript 的核心（e.g. 一切都用 jQuery）；&lt;/p&gt;

&lt;p&gt;2、滥用 JavaScript 插件，无节制的复用别人的代码，哪怕自己根本读不懂；&lt;/p&gt;

&lt;p&gt;3、不看需求、设计，也不做比较或评价，就给 Web 应用程序添加 CSS 框架，却只用到框架的一小部分；&lt;/p&gt;

&lt;p&gt;4、认为只要用了 CSS 框架，网站就是响应式的，或是对响应式设计的意义理解不到位；&lt;/p&gt;

&lt;p&gt;5、一边在说着「响应式 Web 设计」，却对服务器端解决方案技术一无所知；&lt;/p&gt;

&lt;p&gt;6、用 CSS 编程时不做预处理器、命名规范等；&lt;/p&gt;

&lt;p&gt;7、忽视性能、内存泄露（并不理解内存泄露的真正含义），不会检测代码；&lt;/p&gt;

&lt;p&gt;8、不会用指标衡量一个产品，或者这种指标旨在自己的电脑、浏览器、设备有效；&lt;/p&gt;

&lt;p&gt;9、忽视 30 年来的软件工程技术，闭门造车。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;要知道，入门容易精通难，计算机和软件的基础对你用JS或浏览器编程都非常重要。web可能是最有影响力的平台和环境之一，在那里执行的程序必须被小心对待。一位优秀的前端工程师不仅要考虑web技术和语言，并且还要了解所有不同的组件、系统和概念。&lt;/p&gt;

&lt;p&gt;以下是优秀的前端工程师在即时面对普通的任务也会做的事情（这才是市场急需的前端）：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、DNS 解析，使用 CDN，把资源请求分散到多个域名上去；&lt;/p&gt;

&lt;p&gt;2、理解 HTTP Headers (Expires、Cache-Control、If-Modified-Since)&lt;/p&gt;

&lt;p&gt;3、Steve Souders 的所有高性能网页优化规则(参考：High Performance Websites 一书)&lt;/p&gt;

&lt;p&gt;4、如何解决 PageSpeed、YSlow、Chrome Dev Tools Audit、Chrome Dev Tools Timeline 等工具列出的所有问题；&lt;/p&gt;

&lt;p&gt;5、何时把任务传到服务器，何时适合传到客户端；&lt;/p&gt;

&lt;p&gt;6、缓存，预取和延迟加载技术的使用；&lt;/p&gt;

&lt;p&gt;7、原生 JavaScript，知道何时从头开始做，何时参考别人的代码，同时可以评估这样做的优缺点；&lt;/p&gt;

&lt;p&gt;8、 最新的 MVC Javascript 库知识以及用法；&lt;/p&gt;

&lt;p&gt;9、CSS 标准的知识与用法；&lt;/p&gt;

&lt;p&gt;10、JavaScript的计算机科学部分的知识（内存管理，垃圾收集算法等等）&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;换句话说，如果说精通HTML+CSS+JS，了解后端知识，只是60分的合格前端；那么要想成为受追捧、拿高薪的80分优秀前端，要对业务需求和、架构设计有真正的运用；而100分的顶级前端，则必须要能够兼顾技术和设计，更接近「以前端开发为主的全栈工程师」了。&lt;/p&gt;

&lt;h3&gt;100offer 说：市场不是缺少前端，而是缺少优秀的前端工程师&lt;/h3&gt;

&lt;p&gt;现在，前端工程师终于前所未有的在web中占有了一席之地。随着多设备、浏览器和Web标准的演变革命，前端正在成为兼顾逻辑、性能、交互、体验的综合性岗位。&lt;/p&gt;

&lt;p&gt;虽然现在互联网行业普遍缺少前端工程师，但是我们相信越来越多的人将会加入前端的大军。不仅是因为大多数前端工作提供的优渥薪水和办公环境，也是因为web中的前端编程变得越来越有挑战和意义。&lt;/p&gt;

&lt;p&gt;最后，分享一组3~4月的100offer拍卖数据，给前端们鼓鼓劲：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;前端工程师人均收获8.2个面试机会，已入职的前端工程师平均薪资涨幅达39%。其中，前端offer之王共收获47个offer，最高offer薪水38k*16 ，开自某土豪电商。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;加油吧，前端！&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2015/05/14/web-engineer</link>
                <guid>http://yuxiaole.github.io/jekyll/2015/05/14/web-engineer</guid>
                <pubDate>2015-05-14T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>jekyll</title>
                <description>&lt;h1&gt;搭建Github Pages&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　喜欢写Blog的人，会经历三个阶段:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;p&gt;  大多数Blog作者，都停留在第一和第二阶段，因为第三阶段不太容易到达：你很难找到俯首听命、愿意为你管理服务器的人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082501.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  但是两年前，情况出现变化，一些程序员开始在ｇithub网站上搭建blog。他们既拥有绝对管理权，又享受github带来的便利—-不管何时何地，只要向主机提交commit，就能发布新文章。更妙的是，这一切还是免费的，github提供无限流量，世界各地都有理想的访问速度。&lt;/p&gt;

&lt;p&gt;  今天，我就来示范如何在github上搭建Blog，你可以从中掌握github的Pages功能，以及Jekyll软件的基本用法。更重要的是，你会体会到一种建立网站的全新思路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082502.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;一、Github Pages 是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;如果你对编程有所了解，就一定听说过github。它号称程序员的Facebook，有着极高的人气，许多重要的项目都托管在上面。&lt;/p&gt;

&lt;p&gt;简单说，它是一个具有版本管理功能的代码仓库，每个项目都有一个主页，列出项目的源文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082503.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082504.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;github提供模板，允许站内生成网页，但也允许用户自己编写网页，然后上传。有意思的是，这种上传并不是单纯的上传，而是会经过Jekyll程序的再处理。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;二、Jekyll是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Jekyll（发音/&#39;dʒiːk əl/，&quot;杰克尔&quot;）是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，所以实际上可以用来编写整个网站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082505.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个思路到这里就很明显了。你先在本地编写符合Jekyll规范的网站源码，然后上传到github，由github生成并托管整个网站。&lt;/p&gt;

&lt;p&gt;这种做法的好处是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;免费，无限流量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;享受git的版本管理功能，不用担心文章遗失。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你只要用自己喜欢的编辑器写文章就可以了，其他事情一概不用操心，都由github处理。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;它的缺点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一定技术门槛，你必须要懂一点git和网页开发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它生成的是静态网页，添加动态功能必须使用外部服务，比如评论功能就只能用disqus。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它不适合大型网站，因为没有用到数据库，每运行一次都必须遍历全部的文本文件，网站越大，生成时间越长。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;但是，综合来看，它不失为搭建中小型Blog或项目主页的最佳选项之一。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;三、一个实例&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;下面，我举一个实例，演示如何在github上搭建blog，你可以跟着一步步做。为了便于理解，这个blog只有最基本的功能。&lt;/p&gt;

&lt;p&gt;在搭建之前，你必须已经安装了git，并且有github账户。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;第一步，创建项目。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在你的电脑上，建立一个目录，作为项目的主目录。我们假定，它的名称为jekyll_demo。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $ mkdir jekyll_demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对该目录进行git初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $ cd jekyll_demo
　 $ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，创建一个没有父节点的分支gh-pages。因为github规定，只有该分支中的页面，才会生成网页文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　  $ git checkout --orphan gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下所有动作，都在该分支下完成。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;第二步，创建设置文件。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在项目根目录下，建立一个名为_config.yml的文本文件。它是jekyll的设置文件，我们在里面填入如下内容，其他设置都可以用默认选项，具体解释参见官方网页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　  baseurl: /jekyll_demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　 /jekyll_demo
　　　　|--　_config.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第三步，创建模板文件。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在项目根目录下，创建一个_layouts目录，用于存放模板文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　&amp;lt;!DOCTYPE html&amp;gt;

　　&amp;lt;html&amp;gt;

　　  &amp;lt;head&amp;gt;

　　　　 &amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;

　　　　 &amp;lt;title&amp;gt;jekyll&amp;lt;/title&amp;gt;

　　  &amp;lt;/head&amp;gt;

　　  &amp;lt;body&amp;gt;
　　　   　 content
　  　&amp;lt;/body&amp;gt;

　　&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jekyll使用Liquid模板语言，jekyll表示文章标题，表示文章内容，更多模板变量请参考官方文档。&lt;/p&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /jekyll_demo
　　　  　|--　_config.yml
　　　  　|--　_layouts
　　　　  |　　　|--　default.html 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第四步，创建文章。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;回到项目根目录，创建一个_posts目录，用于存放blog文章。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $ mkdir _posts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入该目录，创建第一篇文章。文章就是普通的文本文件，文件名假定为2012-08-25-hello-world.html。(注意，文件名必须为&quot;年-月-日-文章标题.后缀名&quot;的格式。如果网页代码采用html格式，后缀名为html；如果采用markdown格式，后缀名为md。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ---
　　 layout: default
　　 title: 你好，世界
　　---

　　 &amp;lt;h2&amp;gt;jekyll&amp;lt;/h2&amp;gt;

　　 &amp;lt;p&amp;gt;我的第一篇文章&amp;lt;/p&amp;gt;

　　 &amp;lt;p&amp;gt;13 May 2015&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 每篇文章的头部，必须有一个yaml文件头，用来设置一些元数据。它用三根短划线&quot;---&quot;，标记开始和结束，里面每一行设置一种元数据。&quot;layout:default&quot;，表示该文章的模板使用_layouts目录下的default.html文件；&quot;title: 你好，世界&quot;，表示该文章的标题是&quot;你好，世界&quot;，如果不设置这个值，默认使用嵌入文件名的标题，即&quot;hello world&quot;。&lt;/p&gt;

&lt;p&gt;在yaml文件头后面，就是文章的正式内容，里面可以使用模板变量。jekyll就是文件头中设置的&quot;你好，世界&quot;，2015-05-13 00:00:00 -0700则是嵌入文件名的日期（也可以在文件头重新定义date变量），&quot;| date_to_string&quot;表示将page.date变量转化成人类可读的格式。&lt;/p&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /jekyll_demo
　　　   　|--　_config.yml
　　　   　|--　_layouts
　　　   　|　　　|--　default.html
　　　   　|--　_posts
　　　　   |　　　|--　2012-08-25-hello-world.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第五步，创建首页。&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;   ---
　　 layout: default
　　 title: 我的Blog
　　---
   &amp;lt;h2&amp;gt;jekyll&amp;lt;/h2&amp;gt;
　　   &amp;lt;p&amp;gt;最新文章&amp;lt;/p&amp;gt;
　　  &amp;lt;ul&amp;gt;
　　　 　
　　　　　   &amp;lt;li&amp;gt;14 May 2015 &amp;lt;a href=&quot;/2015/05/14/web-engineer&quot;&amp;gt;前端工程师&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;13 May 2015 &amp;lt;a href=&quot;/2015/05/13/jekyll-learn&quot;&amp;gt;jekyll&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;01 May 2015 &amp;lt;a href=&quot;/2015/05/01/sort-algorithm&quot;&amp;gt;各种排序算法总结&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;24 Jan 2015 &amp;lt;a href=&quot;/2015/01/24/goodjob&quot;&amp;gt;Goodjob&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;20 May 2014 &amp;lt;a href=&quot;/2014/05/20/collect_color&quot;&amp;gt;收藏颜色&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;10 May 2014 &amp;lt;a href=&quot;/2014/05/10/template&quot;&amp;gt;Template&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;03 May 2014 &amp;lt;a href=&quot;/2014/05/03/view_render&quot;&amp;gt;view传递context的方式&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;27 Apr 2014 &amp;lt;a href=&quot;/2014/04/27/install-jekyll&quot;&amp;gt;install jekyll 流程&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;25 Apr 2014 &amp;lt;a href=&quot;/2014/04/25/python-code&quot;&amp;gt;python list的技巧&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;24 Apr 2014 &amp;lt;a href=&quot;/2014/04/24/directory&quot;&amp;gt;jekyll加载图片的路径问题&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;23 Apr 2014 &amp;lt;a href=&quot;/2014/04/23/finish-jekyll&quot;&amp;gt;对5天来关于jekyll的心得&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;23 Apr 2014 &amp;lt;a href=&quot;/2014/04/23/chinese-messy-code&quot;&amp;gt;解决invalid byte sequence in GBK&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;21 Apr 2014 &amp;lt;a href=&quot;/2014/04/21/future&quot;&amp;gt;后智能手机时代&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;20 Apr 2014 &amp;lt;a href=&quot;/2014/04/20/githubpages&quot;&amp;gt;GitHub基础入门&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;12 Jan 2013 &amp;lt;a href=&quot;/2013/01/12/prime&quot;&amp;gt;js-算出某值以内的质数&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　  　&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的Yaml文件头表示，首页使用default模板，标题为&quot;我的Blog&quot;。然后，首页使用了 % for post in site.posts %，表示对所有帖子进行一个遍历。这里要注意的是，Liquid模板语言规定，输出内容使用两层大括号，单纯的命令使用一层大括号。至于 site.baseurl 就是_config.yml中设置的baseurl变量。&lt;/p&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /jekyll_demo
　　　　   |--　_config.yml
　　　　   |--　_layouts
　　　　   |　　　|--　default.html
　　　   　|--　_posts
　　　   　|　　　|--　2012-08-25-hello-world.html
　　　   　|--　index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第六步，发布内容。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;现在，这个简单的Blog就可以发布了。先把所有内容加入本地git库。
有了文章以后，还需要有一个首页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   　$ git add .

　　 $ git commit -m &quot;first post&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，前往github的网站，在网站上创建一个名为jekyll_demo的库。接着，再将本地内容推送到github上你刚创建的库。注意，下面命令中的username，要替换成你的username。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ git remote add origin https://github.com/username/jekyll_demo.git

　　 $ git push origin gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上传成功之后，等10分钟左右，访问http://username.github.com/jekyll_demo/就可以看到Blog已经生成了（将username换成你的用户名）。&lt;/p&gt;

&lt;p&gt;首页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082506.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文章页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082507.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;第七步，绑定域名。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;如果你不想用 http://username.github.com/jekyll_demo/ 这个域名，可以换成自己的域名。&lt;/p&gt;

&lt;p&gt;具体方法是在repo的根目录下面，新建一个名为 CNAME 的文本文件，里面写入你要绑定的域名，比如 example.com 或者 xxx.example.com。&lt;/p&gt;

&lt;p&gt;如果绑定的是顶级域名，则DNS要新建一条A记录，指向 204.232.175.78。如果绑定的是二级域名，则DNS要新建一条CNAME记录，指向 username.github.com（请将username换成你的用户名）。此外，别忘了将 _config.yml 文件中的 baseurl 改成根目录&quot;/&quot;。&lt;/p&gt;

&lt;p&gt;至此，最简单的Blog就算搭建完成了。进一步的完善，请参考Jekyll创始人的示例库，以及其他用Jekyll搭建的blog。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2015/05/13/jekyll-learn</link>
                <guid>http://yuxiaole.github.io/jekyll/2015/05/13/jekyll-learn</guid>
                <pubDate>2015-05-13T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>各种排序算法总结</title>
                <description>&lt;h1&gt;各种排序算法总结&lt;/h1&gt;

&lt;hr /&gt;

&lt;h4&gt;排序算法是最基本最常用的算法。&lt;/h4&gt;

&lt;p&gt;不同的排序算法在不同的场景或应用中会有不同的表现，我们需要对各种排序算法熟练才能将它们应用到实际当中，才能更好地发挥它们的优势。今天，来总结下各种排序算法。&lt;/p&gt;

&lt;p&gt;下面这个表格总结了各种排序算法的复杂度与稳定性：&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/273973-ea2745b7ba94af60.png?imageView2/2/w/1240/q/100&quot; alt=&quot;sort&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;冒泡排序&lt;/h4&gt;

&lt;p&gt;冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)，其优点是实现简单，n较小时性能较好。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法原理
  相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;c++代码实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;void bubble_sort(int arr[], int len)
{
      for (int i = 0; i &amp;lt; len - 1; i++)
      {
          for (int j = len - 1; j &amp;gt;= i; j--)
          {
              if (arr[j] &amp;lt; arr[j - 1])
              {
                  int temp = arr[j];
                  arr[j] = arr[j - 1];
                  arr[j - 1] = temp;
              }
          }
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;选择排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法原理
先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;c++代码实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;void select_sort(int arr[], int len)
  {
      for (int i = 0; i &amp;lt; len; i++)
      {
          int index = i;
          for (int j = i + 1; j &amp;lt; len; j++)
          {
              if (arr[j] &amp;lt; arr[index])
                  index = j;
          }
          if (index != i)
          {
              int temp = arr[i];
              arr[i] = arr[index];
              arr[index] = temp; 
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;插入排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法原理
  将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。它是稳定的排序算法，时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;c++代码实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;void insert_sort(int arr[], int len)
  {
      for (int i = 1; i &amp;lt; len; i ++)
      {
          int j = i - 1;
          int k = arr[i];
          while (j &amp;gt; -1 &amp;amp;&amp;amp; k &amp;lt; arr[j] )
          {
              arr[j + 1] = arr[j];
              j --;
          }
          arr[j + 1] = k;
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;快速排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法原理
  快速排序是目前在实践中非常高效的一种排序算法，它不是稳定的排序算法，平均时间复杂度为O(nlogn)，最差情况下复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;c++代码实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;void quick_sort(int arr[], int left, int right)
{
  if (left &amp;lt; right)
  {
      int i = left, j = right, target = arr[left];
      while (i &amp;lt; j)
      {
          while (i &amp;lt; j &amp;amp;&amp;amp; arr[j] &amp;gt; target)
              j--;
          if (i &amp;lt; j)
              arr[i++] = arr[j];

          while (i &amp;lt; j &amp;amp;&amp;amp; arr[i] &amp;lt; target)
              i++;
          if (i &amp;lt; j)
              arr[j] = arr[i];
      }
      arr[i] = target;
      quick_sort(arr, left, i - 1);
      quick_sort(arr, i + 1, right);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;归并排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法原理&lt;/p&gt;

&lt;p&gt;  归并排序具体工作原理如下（假设序列共有n个元素）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * 将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2)个序列，排序后每个序列包含两个元素

 * 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素

 * 重复步骤2，直到所有元素排序完毕
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;归并排序是稳定的排序算法，其时间复杂度为O(nlogn)，如果是使用链表的实现的话，空间复杂度可以达到O(1)，但如果是使用数组来存储数据的话，在归并的过程中，需要临时空间来存储归并好的数据，所以空间复杂度为O(n)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c++代码实现&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;void merge(int arr[], int temp_arr[], int start_index, int mid_index, int end_index)
  {
      int i = start_index, j = mid_index + 1;
      int k = 0;
      while (i &amp;lt; mid_index + 1 &amp;amp;&amp;amp; j &amp;lt; end_index + 1)
      {
          if (arr[i] &amp;gt; arr[j])
              temp_arr[k++] = arr[j++];
          else
              temp_arr[k++] = arr[i++];
      }
      while (i &amp;lt; mid_index + 1)
      {
          temp_arr[k++] = arr[i++];
      }
      while (j &amp;lt; end_index + 1)
          temp_arr[k++] = arr[j++];

      for (i = 0, j = start_index; j &amp;lt; end_index + 1; i ++, j ++)
          arr[j] = temp_arr[i];
  }

  void merge_sort(int arr[], int temp_arr[], int start_index, int end_index)
  {
      if (start_index &amp;lt; end_index)
      {
          int mid_index = (start_index + end_index) / 2;
          merge_sort(arr, temp_arr, start_index, mid_index);
          merge_sort(arr, temp_arr, mid_index + 1, end_index);
          merge(arr, temp_arr, start_index, mid_index, end_index);
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;堆排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;二叉堆&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;二叉堆是完全二叉树或者近似完全二叉树，满足两个特性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  * 父结点的键值总是大于或等于(小于或等于)任何一个子节点的键值

  * 每个结点的左子树和右子树都是一个二叉堆
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。一般二叉树简称为堆。&lt;/p&gt;

&lt;h4&gt;堆的存储&lt;/h4&gt;

&lt;p&gt;一般都是数组来存储堆，&lt;code&gt;i&lt;/code&gt;结点的父结点下标就为&lt;code&gt;(i – 1) / 2&lt;/code&gt;。它的左右子结点下标分别为&lt;code&gt;2 * i + 1&lt;/code&gt;和&lt;code&gt;2 * i + 2&lt;/code&gt;。如第0个结点左右子结点下标分别为1和2。存储结构如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/273973-d6e77b92c0a85ce5.png?imageView2/2/w/1240/q/100&quot; alt=&quot;heap&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;堆排序原理&lt;/h4&gt;

&lt;p&gt;堆排序的时间复杂度为O(nlogn)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法原理（以最大堆为例）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; 先将初始数据R[1..n]建成一个最大堆，此堆为初始的无序区&lt;/li&gt;
&lt;li&gt; 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key&lt;/li&gt;
&lt;li&gt; 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。&lt;/li&gt;
&lt;li&gt; 重复2、3步骤，直到无序区只有一个元素为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;c++代码实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;/**
 * 将数组arr构建大根堆
 * @param arr 待调整的数组
 * @param i   待调整的数组元素的下标
 * @param len 数组的长度
 */
void heap_adjust(int arr[], int i, int len)
{
    int child;
    int temp;

    for (; 2 * i + 1 &amp;lt; len; i = child)
    {
        child = 2 * i + 1;  // 子结点的位置 = 2 * 父结点的位置 + 1
        // 得到子结点中键值较大的结点
        if (child &amp;lt; len - 1 &amp;amp;&amp;amp; arr[child + 1] &amp;gt; arr[child])
            child ++;
        // 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点
        if (arr[i] &amp;lt; arr[child])
        {
            temp = arr[i];
            arr[i] = arr[child];
            arr[child] = temp;
        }
        else
            break;
    }
}

/**
 * 堆排序算法
 */
void heap_sort(int arr[], int len)
{
    int i;
    // 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素
    for (int i = len / 2 - 1; i &amp;gt;= 0; i--)
    {
        heap_adjust(arr, i, len);
    }

    for (i = len - 1; i &amp;gt; 0; i--)
    {
        // 将第1个元素与当前最后一个元素交换，保证当前的最后一个位置的元素都是现在的这个序列中最大的
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        // 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值
        heap_adjust(arr, 0, i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;未完待续&lt;/h4&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2015/05/01/sort-algorithm</link>
                <guid>http://yuxiaole.github.io/jekyll/2015/05/01/sort-algorithm</guid>
                <pubDate>2015-05-01T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Goodjob</title>
                <description>&lt;h1&gt;如何分辨靠谱的互联网公司？&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-ea405e8dfa442cc4.png?imageView2/2/w/1240/q/100&quot; alt=&quot;sort&quot; /&gt;&lt;/p&gt;

&lt;!--break--&gt;


&lt;h4&gt;一、什么样的公司大家愿意加入？&lt;/h4&gt;

&lt;h4&gt;1、所在行业&lt;/h4&gt;

&lt;p&gt;我们这里有2500+公司，但程序员在我们的平台上可以拒绝任何一家发出邀约的公司，我一直很好奇为何有的公司接受率特别高，有的又奇低无比？按行业统计了下他们的邀请接受率，tada~统计答案来了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-167350cf356dc2a5.png&quot; alt=&quot;answer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;O2O、金融、电子商务，是面试邀请接受率最高的行业。可能和市场需求及发展前景相关。&lt;/p&gt;

&lt;h4&gt;2、薪资&lt;/h4&gt;

&lt;p&gt;开出多少薪水对公司而言是量力而为，但愿意开价多少，多多少少体现出企业的诚意。&lt;/p&gt;

&lt;p&gt;其他工作了三五年的程序员现在的薪水如何？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-41920acc40198686.png?imageView2/2/w/1240/q/100&quot; alt=&quot;salary&quot; /&gt;&lt;/p&gt;

&lt;p&gt;并不是给出越高的薪资就是越靠谱的公司，这个之前我们也有过统计。我惊奇地发现，原有薪资涨幅15-40%是一般靠谱的公司会给出的薪资。&lt;/p&gt;

&lt;p&gt;程序员跳槽一次薪资涨幅能达到什么水平？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-fdc19ce95e1608dd.png?imageView2/2/w/1240/q/100&quot; alt=&quot;job&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;被拍卖的优秀程序员offer薪资的平均保守上涨幅度为31.9%。&lt;/h4&gt;

&lt;p&gt;再精准一些，我们看看使用不同语言的程序员的薪资有着怎样的涨幅？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-ddec973fc9b2304c.png?imageView2/2/w/1240/q/100&quot; alt=&quot;language&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;3、看软性指标&lt;/h4&gt;

&lt;p&gt;帮忙找女朋友或者前台妹子很漂亮，对程序员机会选择的影响，为零。&lt;/p&gt;

&lt;p&gt;另外在面试中要考察的因素还有：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-cfd30fb93d40e517.png&quot; alt=&quot;reason&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;二、为什么要拒绝一个看起来不错的机会？&lt;/h4&gt;

&lt;p&gt;意外的是，薪水并不是成熟程序员拒绝面试邀请的最重要指标。&lt;/p&gt;

&lt;p&gt;22岁的毕业生码农和28岁的成熟程序员的生活状态是完全不同的。&lt;/p&gt;

&lt;p&gt;22岁的时候想改变世界也没什么可失去的，只要有不错的机会就能奔过去。&lt;/p&gt;

&lt;p&gt;28岁的时候有家有口有房贷，选择的机会成本更高，自然也就相对保守。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-c83c3109d5c63907.png&quot; alt=&quot;year&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 即便面试邀请在所在城市，离我住地太远也不行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 作为一个成就感导向的手艺人，如果做的项目自己都看不到意义，哪儿有动力写代码？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 待惯了各种制度完善、人员分工明确的大公司，我愿不愿意到创业公司啥都抗？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;三、其他的程序员，他们最后往哪儿跳了？&lt;/h4&gt;

&lt;p&gt;根据100offer的入职名单，程序员跳槽集中在四个领域：电子商务、金融、O2O、在线教育。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/100920-c9b590f07204ae44.png&quot; alt=&quot;sort&quot; /&gt;&lt;/p&gt;

&lt;p&gt;100offer 说：&lt;/p&gt;

&lt;p&gt;当然，上文提供的只是对行业大势的概览，选择是各取所需，把握机会还要充分结合个人情况。&lt;/p&gt;

&lt;p&gt;还是要强调，跳槽是手段不是目的。在跳槽大潮中保持个人理性，一切都是为了更好的生活。&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2015/01/24/goodjob</link>
                <guid>http://yuxiaole.github.io/jekyll/2015/01/24/goodjob</guid>
                <pubDate>2015-01-24T00:00:00-08:00</pubDate>
        </item>

        <item>
                <title>收藏颜色</title>
                <description>&lt;h1&gt;收藏颜色的工具&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://enml.github.io/blog/image/collect_color.jpg&quot; alt=&quot;collect_color&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用了三个小时完成了上图的功能，满足了我的需求。&lt;/p&gt;

&lt;p&gt;只要在输入框输入颜色数值，便可记录到数据库，并把颜色作为该数值背景色输出页面。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;本来是在寻找一个可以保存自己喜欢的颜色的工具，一开始想着记录在onenote，但是只能记录数值，不够直观。如果把图片粘贴过去会很繁琐并且不够雅观。后来把颜色直接合并在一张图上，但记录时每次都需要进行图片修改，繁琐也依然不美观。中午午睡后百度了一下是否有相关的在线工具，一无所获。突然想着要不自己搞一个吧！在脑海里构建了一下基本框架后觉得可行，便开始编写代码。花了三个小时总算实现了。&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/05/20/collect_color</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/05/20/collect_color</guid>
                <pubDate>2014-05-20T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Template</title>
                <description>&lt;h1&gt;Template&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;在view里面，我们获取了相关的数据，但我们的目的是将数据呈现出来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.首先我们想到的是直接把数据硬编码到html代码里面，然后通过&lt;code&gt;HttpResponse&lt;/code&gt;对象传递给浏览器进行渲染：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % now
    return HttpResponse(html)
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;但是很明显这种方法不适合生产环境，你不可能把整个html页面都硬编码在view里面，因为这显得既愚蠢又低效。对于template的改动很明显要比view频繁得多，这种方式意味着你想更改页面表现时都必须得改动python代码，并且前后端无法同步开发。于是有了第二种方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.把html代码分离成独立的模板，通过加载模板文件进行渲染，这样可以实现前后端分离：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;   #view
from django.shortcuts import render_to_response
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response(&#39;current_datetime.html&#39;, {&#39;current_date&#39;: now})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#template
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now .&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过render()传递数据给template的方式在上一篇文章有列举出来。这种模式的好处很明显。但我们又遇到一个问题：&lt;strong&gt;假如我的网站有100个页面，那我是不是要写100个template呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道这样是愚蠢。编程中有一个很重要的思想就是--&lt;strong&gt;最大限度地实现代码重用。&lt;/strong&gt; 而我们写100个页面的重复代码可能已经超过40%了，这不但费时费力，你还可能见笑于大方之家。所以我们有一种优雅的解决方式：&lt;strong&gt;include&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1). 把重用代码分离出来，比如header.html,footer.html,sidebar.html；然后&lt;code&gt;include&lt;/code&gt;到content.html中。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# header.html

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # footer.html

        &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# include &#39;header&#39; and &#39;footer&#39;

{ include &#39;header.html&#39; %}
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
{ include &#39;footer.html&#39; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，这样很优雅，可以实现代码重用。但是仍然有个问题：当代码中存在哪怕一个标记不同时，这部分代码你就无法分离出来，这导致了你仍然需要重复大量的代码。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# first page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# second page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Future time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个页面中&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;不同，意味着&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;以下的部分都不能并入&lt;code&gt;header.html&lt;/code&gt;中，哪怕下面仍然存在大量的重复代码。所以有了更优雅的解决办法：&lt;strong&gt;extends&lt;/strong&gt; -- inculde的逆向思维。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2). 我们把模板里面的‘不同代码’进行定义，相同的代码保存为base模板&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{ block title %}{ endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    { block content %}{ endblock %}
    { block footer %}
    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    { endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;base.html&lt;/code&gt;变成了一个骨架，你可以把需要的内容填充进去即可，这最大限度实现了代码重用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # first page

    { extends &quot;base.html&quot; %}

    { block title %}The current time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # second page

    { extends &quot;base.html&quot; %}

    { block title %}Future time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;woo! 简单优雅！这是Template设计的思想历程。&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/05/10/template</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/05/10/template</guid>
                <pubDate>2014-05-10T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>view传递context的方式</title>
                <description>&lt;h1&gt;view传递context的方式&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt; 通过view的render()方法填充template可以有以下方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.适合于数据量小且静态的数据。在template中直接使用相关键值为标签：
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test1(request):
    return render(request,&#39;test/raw.htm&#39;,{
                &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False})
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;2.通过调用属性的方式传递整个dictionary。但在template中必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test2():
    person = {  &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,{ &#39;person&#39;:person, &#39;dict&#39;:dict})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.使用&lt;strong&gt;locals(),locals()&lt;/strong&gt; 是个字典，直接赋值给变量。很明显这种方式更加优雅和便捷，但缺点就是它会把所有的dictionary都传递，也就是说它默认传递的值可能会比你预想中的多。&lt;/p&gt;

&lt;p&gt;   template中仍然必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test3():
    person = {  &#39;name&#39;: &#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,locals())
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/05/03/view_render</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/05/03/view_render</guid>
                <pubDate>2014-05-03T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>install jekyll 流程</title>
                <description>&lt;h1&gt;install jekyll 流程&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载&lt;code&gt;ruby&lt;/code&gt;&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;安装ruby download&lt;/a&gt; ，然后下载&lt;strong&gt;DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe&lt;/strong&gt;。安装完&lt;code&gt;ruby&lt;/code&gt;后，再安装&lt;code&gt;rubyGems&lt;/code&gt;:运行&lt;code&gt;gem update --system&lt;/code&gt;即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压DevKit，然后命令行cd到该目录，运行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;pre&gt;&lt;code&gt; ruby dk.rb init
 ruby dk.rb review 
 ruby dk.rb install
 gem install rdiscount --platform=ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DevKit安装完后，即可安装jekyll：&lt;code&gt;gem install jekyll&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/27/install-jekyll</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/27/install-jekyll</guid>
                <pubDate>2014-04-27T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>python list的技巧</title>
                <description>&lt;h1&gt;Python list的一些技巧&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;列表相邻元素压缩器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; zip(*([iter(a)] * 2))
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::2], a[1::2])
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::3], a[1::3], a[2::3])
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*(a[i::k] for i in range(k)))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;用压缩器反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m.items()
[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]
&amp;gt;&amp;gt;&amp;gt; zip(m.values(), m.keys())
[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]
&amp;gt;&amp;gt;&amp;gt; mi = dict(zip(m.values(), m.keys()))
&amp;gt;&amp;gt;&amp;gt; mi
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表展开&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2], [3, 4], [5, 6]]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain.from_iterable(a))
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; sum(a, [])
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; [x for l in a for x in l]
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; [x for l1 in a for l2 in l1 for x in l2]
[1, 2, 3, 4, 5, 6, 7, 8]

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
&amp;gt;&amp;gt;&amp;gt; flatten(a)
[1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;生成器表达式&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g = (x ** 2 for x in xrange(10))
&amp;gt;&amp;gt;&amp;gt; next(g)
0
&amp;gt;&amp;gt;&amp;gt; next(g)
1
&amp;gt;&amp;gt;&amp;gt; next(g)
4
&amp;gt;&amp;gt;&amp;gt; next(g)
9
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10))
2025
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)
408
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;字典推导&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {x: x ** 2 for x in range(5)}
&amp;gt;&amp;gt;&amp;gt; m
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; m = {x: &#39;A&#39; + str(x) for x in range(10)}
&amp;gt;&amp;gt;&amp;gt; m
{0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用字典推导反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m
{&#39;d&#39;: 4, &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&amp;gt;&amp;gt;&amp;gt; {v: k for k, v in m.items()}
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Point = collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p
Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p.x
1.0
&amp;gt;&amp;gt;&amp;gt; p.y
2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;继承命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Point(collections.namedtuple(&#39;PointBase&#39;, [&#39;x&#39;, &#39;y&#39;])):
...     __slots__ = ()
...     def __add__(self, other):
...             return Point(x=self.x + other.x, y=self.y + other.y)
...
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; q = Point(x=2.0, y=3.0)
&amp;gt;&amp;gt;&amp;gt; p + q
Point(x=3.0, y=5.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有最大长度的双端队列&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; last_three = collections.deque(maxlen=3)
&amp;gt;&amp;gt;&amp;gt; for i in xrange(10):
...     last_three.append(i)
...     print &#39;, &#39;.join(str(x) for x in last_three)
...
0
0, 1
0, 1, 2
1, 2, 3
2, 3, 4
3, 4, 5
4, 5, 6
5, 6, 7
6, 7, 8
7, 8, 9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可排序词典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = dict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
1, 0, 3, 2, 5, 4, 7, 6, 9, 8
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
10, 9, 8, 7, 6, 5, 4, 3, 2, 1
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/25/python-code</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/25/python-code</guid>
                <pubDate>2014-04-25T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>jekyll加载图片的路径问题</title>
                <description>&lt;h1&gt;jekyll加载图片的路径问题&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　一开始使用根目录&lt;code&gt;/assets/…/img/bg.png&lt;/code&gt;的方式，在localhost调试成功，但在github pages失败。
　后来试了一下当前目录方式&lt;code&gt;./img/bg.png&lt;/code&gt;成功。也可以用&lt;code&gt;img/bg.png&lt;/code&gt;表示当前目录。&lt;/p&gt;

&lt;!--break--&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/24/directory</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/24/directory</guid>
                <pubDate>2014-04-24T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>对5天来关于jekyll的心得</title>
                <description>&lt;h1&gt;完成基于jekyll的第一个blog&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　今天差不多把blog完成了，这是我第一个基于jekyll的blog，定制了主题，修改了相关配置，以及解决了中文bug。现在把这5天的心得分享一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先是中文问题，这个困扰我了很久，也花费了不少时间，不过最后总算找到解决办法。给我最大的感触就是，即使碰壁，也得硬着头皮找下去，如果放弃，那就前功尽弃了。&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后是关于bootstrap，因为主题是基于bootstrap，所以这几天对bootstrap也有了深入的了解。Less预编译的思想其实挺方便的，只不过先前习惯了直接div+css的方式后一时难以习惯，但是，习惯是用来打破，不打破那永远都进不了步。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@media通过检测min-width和max-width来进行响应式布局，但要编写全局css时要注意，否则很容易响应不了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\&lt;hr&gt; 添加个具有margin的hr，然后在使用card style时可以通过添加hr来达到分割的效果。另一种方式是直接为card添加一个margin-top。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当我使用中文的categories时，由于permalink中包含categories，导致链接失败。所以只要到_config.yml中修改permalink即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/23/finish-jekyll</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/23/finish-jekyll</guid>
                <pubDate>2014-04-23T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>解决invalid byte sequence in GBK</title>
                <description>&lt;h1&gt;解决invalid byte sequence in GBK&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　jekyll对中文的支持不太好，导致经常出现乱码甚至无法运行&lt;code&gt;jekyll server&lt;/code&gt;命令。解决post内容乱码问题可以通过修改convertible.rb文件的第27行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name), :encoding =&amp;gt; &quot;utf-8&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　原因File.read()可能采用系统默认编码读取文件，中文系统为GBK，但markdown文件均为utf-8编码，所以导致无法正确展现中文。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　但是当我在post.html模板里面加入中文之后，&lt;code&gt;jekyll server&lt;/code&gt;命令直接报错。解决办法是在运行服务器前先运行&lt;code&gt;chcp 65001&lt;/code&gt;命令，即可解决。在官方找到的解决办法&lt;strong&gt;Windows users: run chcp 65001 first to change the command prompt&#39;s character encoding (code page) to UTF-8 so Jekyll runs without errors.&lt;/strong&gt;&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/23/chinese-messy-code</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/23/chinese-messy-code</guid>
                <pubDate>2014-04-23T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>后智能手机时代</title>
                <description>&lt;h1&gt;谁将取代智能手机&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wccbr.com/wp-content/uploads/2013/03/Robot_Wallpaper_1.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能手表&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　现在手表被炒的很热，但以目前来看，手表只是一个辅佐设备；注定手表不可能超越智能手机。手表的特点在于屏幕小，便携，查看信息快速直接；但屏幕小也是它的极限性（屏幕扩大了跟智能手机就没差别了），决定了它不适合发展成独立的终端，你能想象拿着手表刷微博看知乎发邮件吗？&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　除非发展出了超越平面显示的信息展现方式，比如说已经被说烂了的“全息投影”。否则手表永远只能是手机的辅佐设备。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能眼镜&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这货一开始我不看好，谁tm想戴个电池cpu在太阳穴那里，而且带了几年眼镜的我表示对眼镜深痛恶绝啊。后来了解了google glass之后，我发现这货绝对是未来。不，我是说这个方向。&lt;/p&gt;

&lt;p&gt;　为什么智能眼镜有潜力取代智能手机呢？首先，我们从电子设备的发展历程可以看出，任何具有划时代的产品都是通过对人机交互方式进行革新。从命令行跨越到图形界面，从物理按键跨越到触摸，从遥控器跨越到体感声控……再看看手表，再怎么有想象力它始终只是一部小尺寸精简化的手机绑在手上，不管是现在市面上丑陋不堪的炒作产品，还是被寄予厚望的iwatch，都难以在信息展现方式上得到突破；再看看眼镜，信息是直接投射到视网膜上，信息展现方式已经不再局限于屏幕的大小，你眼前的整个视角都是屏幕，甚至可以通过调节投射的焦距而达到调节屏幕的大小，那可想像的空间可就大了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为展现信息独特的视角，眼镜可以覆盖你的整个视角，它可以挡住外来的光线让你完全沉浸在数字光影之中；你可以随时随地享受不亚于甚至超越IMAX的视觉盛宴。是的，我说的不是3D眼镜。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为现实与虚拟的无缝结合，你去超市或者在复杂的商业街寻找餐馆，你不用再打开地图或者大众点评，你眼前就是信息与现实的结合体；如果你用过nokia的city lens，你一定知道我在说什么。你不用再厚着脸皮去找心仪的妹子要联系方式了，只要她在社交网络公开信息，你盯着她看几秒可能就已经加了她的微信或者facebook了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为“所见即所得”，你所能看到的美景都可以收入囊中，不会再因为掏出手机解锁打开相机应用而错过稍众即逝的美景。当然，google glass现在因为这个产生的隐私问题而备受争议。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;……还有很大的想象空间，只是我想不出来了。但是如果做到以上3点，你完全可以抛弃你的智能机了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　以上，并不是空穴来风的天方夜谭，不信，你试着在手表上想象一下。这些是基于信息展现方式，或者说是交互方式的革新。google glass目前并不足以产生颠覆性，产品还不完善，技术也难以突破，生态更是一片荒芜，但它叩开了一个全新世界的大门，这个大门后面的世界才是未来。说实话，我更期待苹果和微软在这方面的突破。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;机器人&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这条路任重而道远，真的要发展出人工智能的话，很可能要对现有的计算机体系、软硬架构、甚至编程思想统统进行颠覆才有可能。但是，100年后每个人身边陪着个高度智能的机器人作助手甚至伴侣应该没什么好争议的。那时候什么手机电脑手表眼镜通通可以扔掉了，人可以真正得到解放，这个随时随地跟着你的机器人就是你最好最强大的电子设备了。你要打电话，你就跟它说帮我call一下奥巴马；你要玩游戏，它转过身来可能后背就是一块触摸屏；你要写代码，哦，那时候应该不用写代码了……&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/21/future</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/21/future</guid>
                <pubDate>2014-04-21T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>GitHub基础入门</title>
                <description>&lt;h1&gt;GitHub Pages（像黑客一样写博客）&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;技术&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;是的，之前github的名字其实早已经如雷贯耳，只是我对它望而生畏，始终不敢去触碰它。因为它咋一看上去冷冰冰的，眼之所及，皆为代码；并且又找不到能详细却直观地描述它的理念的教程，所以我始终无从下手。&lt;/p&gt;

&lt;p&gt;终于，两天前看到&lt;strong&gt;Blogging like a hacker&lt;/strong&gt;这篇文章，决定试试搭建一个基于&lt;strong&gt;github pages&lt;/strong&gt;的blog，遂开始尝试。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;首先下载&lt;code&gt;github&lt;/code&gt;的windows客户端，客户端很简约，这个非常值得称赞。客户端登录后会直接跟你github账号进行绑定同步，因此你能直观的看到github上你的项目文件。硬着头皮尝试各种git命令，不求甚解。以前我很讨厌这种不求甚解的状态，当我在阅读一篇教程时总是希望先了解一下基本脉络，当差不多头脑里有个整体框架后再动手，这样的好处就是你知道你每一步是在做什么，成功率也比较高。但并不是每一篇教程或者每一个项目你都能很快地掌握其基本脉络，就像github。很多教程基本就是直接说输入&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;git push origin master&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;之类的，但他没告诉我输入之后能干什么，会发生什么。更没有人告诉我每一次必须先commit message才能提交。所以我只能糊里糊涂地跟着教程走，不过尝试了几遍之后，也就大概理解了脉络。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github为版本控制系统。也就是说，你每一次的提交都会有相关的标记，以便进行回滚和协作。&lt;/li&gt;
&lt;li&gt;对于远程代码，可以通过&lt;code&gt;git clone&lt;/code&gt;语句进行clone，可以clone到本地库，也可以clone到github库中。&lt;/li&gt;
&lt;li&gt;对于本地代码，可以通过&lt;code&gt;git remote set-url&lt;/code&gt;语句绑定到对应的repository；也可以通过客户端里的public推送到github上。&lt;/li&gt;
&lt;li&gt;每一次push前必须先commit -m，客户端里是填写相应的summary。&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/20/githubpages</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/20/githubpages</guid>
                <pubDate>2014-04-20T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>js-算出某值以内的质数</title>
                <description>&lt;h1&gt;js 算出某值以内的质数&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
    //算出 num 以内的所有质数
 
function prime(num){
    var list = [];
    for(var i = 2; i &lt;= num; i++){ list.push(i); } //create a Array
    
    for(var i = 0; i &lt; list.length; i++){
        for(var j = 2; j &lt; list[i]; j++){
            if(list[i] % j == 0){
                list.splice(i,1); //delete the non prime number.it will change the index of other elements
                j = 2; //由于splice导致list[i+1]的index变为i,因此把j置为2以便对list[i+1]进行重新计算
        }
    }
}
&lt;/pre&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2013/01/12/prime</link>
                <guid>http://yuxiaole.github.io/jekyll/2013/01/12/prime</guid>
                <pubDate>2013-01-12T00:00:00-08:00</pubDate>
        </item>


</channel>
</rss>
