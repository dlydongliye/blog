<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>yuandaima</title>
        <description>yuandaima - yuandaima</description>
        <link>http://yuxiaole.github.io/jekyll</link>
        <link>http://yuxiaole.github.io/jekyll</link>
        <lastBuildDate>2015-05-14T02:08:42-07:00</lastBuildDate>
        <pubDate>2015-05-14T02:08:42-07:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>redis</title>
                <description>&lt;h1&gt;搭建Redis以及使用&lt;/h1&gt;

&lt;hr /&gt;

&lt;h4&gt;Redis的安装&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在官网下载tar.gz的文件，并且解压，进入解压目录，执行 make&amp;amp;&amp;amp;make install，在make成功以后，会在src目录下多出一些可执行文件：redis-server，redis-cli等等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用cp命令复制到usr目录下运行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;cp redis-server /usr/local/bin/&lt;/p&gt;

&lt;p&gt;cp redis-cli /usr/local/bin/&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;新建目录，存放配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;blockquote&gt;&lt;p&gt;mkdir /etc/redis&lt;/p&gt;

&lt;p&gt;mkdir /var/redis&lt;/p&gt;

&lt;p&gt;mkdir /var/redis/log&lt;/p&gt;

&lt;p&gt;mkdir /var/redis/run&lt;/p&gt;

&lt;p&gt;mkdir /var/redis/6379&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;在redis解压根目录中找到配置文件模板，复制到如下位置。&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;cp redis.conf /etc/redis/6379.conf&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;因为在etc目录下文件只读，所以建议先在其他目录更改conf文件，然后在cp到redis&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;daemonize yes&lt;/p&gt;

&lt;p&gt;pidfile /var/redis/run/redis_6379.pid&lt;/p&gt;

&lt;p&gt;logfile /var/redis/log/redis_6379.log&lt;/p&gt;

&lt;p&gt;dir /var/redis/6379&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;最后运行redis：&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;$ redis-server /etc/redis/6379.conf&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;启动redis-cli：&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;/usr/local/bin/redis-cli&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;命令示例&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;KEYS/RENAME/DEL/EXISTS/MOVE/RENAMENX:&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;在Shell命令行下启动Redis客户端工具。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;/&gt; redis-cli&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;清空当前选择的数据库，以便于对后面示例的理解。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; flushdb&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;添加String类型的模拟数据。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; set mykey 2&lt;/p&gt;

&lt;p&gt;  OK&lt;/p&gt;

&lt;p&gt;  redis 127.0.0.1:6379&gt; set mykey2 &quot;hello&quot;&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;添加Set类型的模拟数据。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;  redis 127.0.0.1:6379&gt; sadd mysetkey 1 2 3&lt;/p&gt;

&lt;p&gt;  (integer) 3&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;添加Hash类型的模拟数据。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; hset mmtest username &quot;stephen&quot;&lt;/p&gt;

&lt;p&gt;  (integer) 1&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;根据参数中的模式，获取当前数据库中符合该模式的所有key，从输出可以看出，该命令在执行时并不区分与Key关联的Value类型。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; keys my*&lt;/p&gt;

&lt;p&gt;  1) &quot;mysetkey&quot;&lt;/p&gt;

&lt;p&gt;   2) &quot;mykey&quot;&lt;/p&gt;

&lt;p&gt;   3) &quot;mykey2&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;删除了两个Keys。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;  redis 127.0.0.1:6379&gt; del mykey mykey2&lt;/p&gt;

&lt;p&gt;  (integer) 2&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;查看一下刚刚删除的Key是否还存在，从返回结果看，mykey确实已经删除了。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;  redis 127.0.0.1:6379&gt; exists mykey&lt;/p&gt;

&lt;p&gt;  (integer) 0&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;查看一下没有删除的Key，以和上面的命令结果进行比较。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;  redis 127.0.0.1:6379&gt; exists mysetkey&lt;/p&gt;

&lt;p&gt;   (integer) 1&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;将当前数据库中的mysetkey键移入到ID为1的数据库中，从结果可以看出已经移动成功。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; move mysetkey 1&lt;/p&gt;

&lt;p&gt;  (integer) 1&lt;/p&gt;

&lt;h5&gt;打开ID为1的数据库。&lt;/h5&gt;

&lt;p&gt;  redis 127.0.0.1:6379&gt; select 1&lt;/p&gt;

&lt;p&gt;  OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;查看一下刚刚移动过来的Key是否存在，从返回结果看已经存在了。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379[1]&gt; exists mysetkey&lt;/p&gt;

&lt;p&gt;  (integer) 1&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;在重新打开ID为0的缺省数据库。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379[1]&gt; select 0&lt;/p&gt;

&lt;p&gt;  OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;查看一下刚刚移走的Key是否已经不存在，从返回结果看已经移走。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; exists mysetkey&lt;/p&gt;

&lt;p&gt;  (integer) 0&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;准备新的测试数据。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;&lt;/p&gt;

&lt;p&gt;  OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;将mykey改名为mykey1&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; rename mykey mykey1&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;由于mykey已经被重新命名，再次获取将返回nil。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; get mykey&lt;/p&gt;

&lt;p&gt;   (nil)&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;通过新的键名获取。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; get mykey1&lt;/p&gt;

&lt;p&gt;  &quot;hello&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;由于mykey已经不存在了，所以返回错误信息。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; rename mykey mykey1&lt;/p&gt;

&lt;p&gt;   (error) ERR no such key&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;为renamenx准备测试key&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; set oldkey &quot;hello&quot;&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;

&lt;p&gt;   redis 127.0.0.1:6379&gt; set newkey &quot;world&quot;&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;由于newkey已经存在，因此该命令未能成功执行。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; renamenx oldkey newkey&lt;/p&gt;

&lt;p&gt;   (integer) 0&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;查看newkey的值，发现它也没有被renamenx覆盖。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; get newkey&lt;/p&gt;

&lt;p&gt;   &quot;world&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;PERSIST/EXPIRE/EXPIREAT/TTL:&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;为后面的示例准备的测试数据。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;将该键的超时设置为100秒。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; expire mykey 100&lt;/p&gt;

&lt;p&gt;  (integer) 1&lt;/p&gt;

&lt;h5&gt;通过ttl命令查看一下还剩下多少秒。&lt;/h5&gt;

&lt;p&gt;   redis 127.0.0.1:6379&gt; ttl mykey&lt;/p&gt;

&lt;p&gt;   (integer) 97&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;立刻执行persist命令，该存在超时的键变成持久化的键，即将该Key的超时去掉。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; persist mykey&lt;/p&gt;

&lt;p&gt;   (integer) 1&lt;/p&gt;

&lt;h5&gt;ttl的返回值告诉我们，该键已经没有超时了。&lt;/h5&gt;

&lt;p&gt;   redis 127.0.0.1:6379&gt; ttl mykey&lt;/p&gt;

&lt;p&gt;   (integer) -1&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;为后面的expire命令准备数据。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; del mykey&lt;/p&gt;

&lt;p&gt;   (integer) 1&lt;/p&gt;

&lt;p&gt;   redis 127.0.0.1:6379&gt; set mykey &quot;hello&quot;&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;设置该键的超时被100秒。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; expire mykey 100&lt;/p&gt;

&lt;p&gt;   (integer) 1&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;用ttl命令看一下当前还剩下多少秒，从结果中可以看出还剩下96秒。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; ttl mykey&lt;/p&gt;

&lt;p&gt;   (integer) 96&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;重新更新该键的超时时间为20秒，从返回值可以看出该命令执行成功。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; expire mykey 20&lt;/p&gt;

&lt;p&gt;   (integer) 1&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;再用ttl确认一下，从结果中可以看出果然被更新了。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; ttl mykey&lt;/p&gt;

&lt;p&gt;   (integer) 17&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;立刻更新该键的值，以使其超时无效。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; set mykey &quot;world&quot;&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;从ttl的结果可以看出，在上一条修改该键的命令执行后，该键的超时也无效了。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; ttl mykey&lt;/p&gt;

&lt;p&gt;   (integer) -1&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;TYPE/RANDOMKEY/SORT:&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;由于mm键在数据库中不存在，因此该命令返回none。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; type mm&lt;/p&gt;

&lt;p&gt;   none&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;mykey的值是字符串类型，因此返回string。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; type mykey&lt;/p&gt;

&lt;p&gt;   string&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;准备一个值是set类型的键。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; sadd mysetkey 1 2&lt;/p&gt;

&lt;p&gt;   (integer) 2&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;mysetkey的键是set，因此返回字符串set。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; type mysetkey&lt;/p&gt;

&lt;p&gt;   set&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;返回数据库中的任意键。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; randomkey&lt;/p&gt;

&lt;p&gt;   &quot;oldkey&quot;&lt;/p&gt;

&lt;h5&gt;清空当前打开的数据库。&lt;/h5&gt;

&lt;p&gt;   redis 127.0.0.1:6379&gt; flushdb&lt;/p&gt;

&lt;p&gt;   OK&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;由于没有数据了，因此返回nil。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;   redis 127.0.0.1:6379&gt; randomkey&lt;/p&gt;

&lt;p&gt;   (nil)&lt;/p&gt;&lt;/blockquote&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2015/05/14/redis-learn</link>
                <guid>http://yuxiaole.github.io/jekyll/2015/05/14/redis-learn</guid>
                <pubDate>2015-05-14T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>jekyll</title>
                <description>&lt;h1&gt;搭建Github Pages&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　喜欢写Blog的人，会经历三个阶段:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。&lt;/p&gt;

&lt;p&gt;大多数Blog作者，都停留在第一和第二阶段，因为第三阶段不太容易到达：你很难找到俯首听命、愿意为你管理服务器的人。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082501.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;  但是两年前，情况出现变化，一些程序员开始在ｇithub网站上搭建blog。他们既拥有绝对管理权，又享受github带来的便利—-不管何时何地，只要向主机提交commit，就能发布新文章。更妙的是，这一切还是免费的，github提供无限流量，世界各地都有理想的访问速度。&lt;/p&gt;

&lt;p&gt;  今天，我就来示范如何在github上搭建Blog，你可以从中掌握github的Pages功能，以及Jekyll软件的基本用法。更重要的是，你会体会到一种建立网站的全新思路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082502.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;一、Github Pages 是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;如果你对编程有所了解，就一定听说过github。它号称程序员的Facebook，有着极高的人气，许多重要的项目都托管在上面。&lt;/p&gt;

&lt;p&gt;简单说，它是一个具有版本管理功能的代码仓库，每个项目都有一个主页，列出项目的源文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082503.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082504.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;github提供模板，允许站内生成网页，但也允许用户自己编写网页，然后上传。有意思的是，这种上传并不是单纯的上传，而是会经过Jekyll程序的再处理。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;二、Jekyll是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Jekyll（发音/&#39;dʒiːk əl/，&quot;杰克尔&quot;）是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，所以实际上可以用来编写整个网站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082505.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个思路到这里就很明显了。你先在本地编写符合Jekyll规范的网站源码，然后上传到github，由github生成并托管整个网站。&lt;/p&gt;

&lt;p&gt;这种做法的好处是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;免费，无限流量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;享受git的版本管理功能，不用担心文章遗失。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你只要用自己喜欢的编辑器写文章就可以了，其他事情一概不用操心，都由github处理。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;它的缺点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一定技术门槛，你必须要懂一点git和网页开发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它生成的是静态网页，添加动态功能必须使用外部服务，比如评论功能就只能用disqus。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它不适合大型网站，因为没有用到数据库，每运行一次都必须遍历全部的文本文件，网站越大，生成时间越长。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;但是，综合来看，它不失为搭建中小型Blog或项目主页的最佳选项之一。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;三、一个实例&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;下面，我举一个实例，演示如何在github上搭建blog，你可以跟着一步步做。为了便于理解，这个blog只有最基本的功能。&lt;/p&gt;

&lt;p&gt;在搭建之前，你必须已经安装了git，并且有github账户。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;第一步，创建项目。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在你的电脑上，建立一个目录，作为项目的主目录。我们假定，它的名称为jekyll_demo。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $ mkdir jekyll_demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对该目录进行git初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $ cd jekyll_demo
　 $ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，创建一个没有父节点的分支gh-pages。因为github规定，只有该分支中的页面，才会生成网页文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　  $ git checkout --orphan gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下所有动作，都在该分支下完成。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;第二步，创建设置文件。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在项目根目录下，建立一个名为_config.yml的文本文件。它是jekyll的设置文件，我们在里面填入如下内容，其他设置都可以用默认选项，具体解释参见官方网页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　  baseurl: /jekyll_demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　 /jekyll_demo
　　　　|--　_config.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第三步，创建模板文件。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在项目根目录下，创建一个_layouts目录，用于存放模板文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　&amp;lt;!DOCTYPE html&amp;gt;

　　&amp;lt;html&amp;gt;

　　  &amp;lt;head&amp;gt;

　　　　 &amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;

　　　　 &amp;lt;title&amp;gt;jekyll&amp;lt;/title&amp;gt;

　　  &amp;lt;/head&amp;gt;

　　  &amp;lt;body&amp;gt;
　　　   　 content
　  　&amp;lt;/body&amp;gt;

　　&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jekyll使用Liquid模板语言，jekyll表示文章标题，表示文章内容，更多模板变量请参考官方文档。&lt;/p&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /jekyll_demo
　　　  　|--　_config.yml
　　　  　|--　_layouts
　　　　  |　　　|--　default.html 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第四步，创建文章。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;回到项目根目录，创建一个_posts目录，用于存放blog文章。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $ mkdir _posts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入该目录，创建第一篇文章。文章就是普通的文本文件，文件名假定为2012-08-25-hello-world.html。(注意，文件名必须为&quot;年-月-日-文章标题.后缀名&quot;的格式。如果网页代码采用html格式，后缀名为html；如果采用markdown格式，后缀名为md。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ---
　　 layout: default
　　 title: 你好，世界
　　---

　　 &amp;lt;h2&amp;gt;jekyll&amp;lt;/h2&amp;gt;

　　 &amp;lt;p&amp;gt;我的第一篇文章&amp;lt;/p&amp;gt;

　　 &amp;lt;p&amp;gt;13 May 2015&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 每篇文章的头部，必须有一个yaml文件头，用来设置一些元数据。它用三根短划线&quot;---&quot;，标记开始和结束，里面每一行设置一种元数据。&quot;layout:default&quot;，表示该文章的模板使用_layouts目录下的default.html文件；&quot;title: 你好，世界&quot;，表示该文章的标题是&quot;你好，世界&quot;，如果不设置这个值，默认使用嵌入文件名的标题，即&quot;hello world&quot;。&lt;/p&gt;

&lt;p&gt;在yaml文件头后面，就是文章的正式内容，里面可以使用模板变量。jekyll就是文件头中设置的&quot;你好，世界&quot;，2015-05-13 00:00:00 -0700则是嵌入文件名的日期（也可以在文件头重新定义date变量），&quot;| date_to_string&quot;表示将page.date变量转化成人类可读的格式。&lt;/p&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /jekyll_demo
　　　   　|--　_config.yml
　　　   　|--　_layouts
　　　   　|　　　|--　default.html
　　　   　|--　_posts
　　　　   |　　　|--　2012-08-25-hello-world.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第五步，创建首页。&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;   ---
　　 layout: default
　　 title: 我的Blog
　　---
   &amp;lt;h2&amp;gt;jekyll&amp;lt;/h2&amp;gt;
　　   &amp;lt;p&amp;gt;最新文章&amp;lt;/p&amp;gt;
　　  &amp;lt;ul&amp;gt;
　　　 　
　　　　　   &amp;lt;li&amp;gt;14 May 2015 &amp;lt;a href=&quot;/2015/05/14/redis-learn&quot;&amp;gt;redis&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;13 May 2015 &amp;lt;a href=&quot;/2015/05/13/jekyll-learn&quot;&amp;gt;jekyll&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;20 May 2014 &amp;lt;a href=&quot;/2014/05/20/collect_color&quot;&amp;gt;收藏颜色&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;10 May 2014 &amp;lt;a href=&quot;/2014/05/10/template&quot;&amp;gt;Template&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;03 May 2014 &amp;lt;a href=&quot;/2014/05/03/view_render&quot;&amp;gt;view传递context的方式&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;27 Apr 2014 &amp;lt;a href=&quot;/2014/04/27/install-jekyll&quot;&amp;gt;install jekyll 流程&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;25 Apr 2014 &amp;lt;a href=&quot;/2014/04/25/python-code&quot;&amp;gt;python list的技巧&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;24 Apr 2014 &amp;lt;a href=&quot;/2014/04/24/directory&quot;&amp;gt;jekyll加载图片的路径问题&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;23 Apr 2014 &amp;lt;a href=&quot;/2014/04/23/finish-jekyll&quot;&amp;gt;对5天来关于jekyll的心得&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;23 Apr 2014 &amp;lt;a href=&quot;/2014/04/23/chinese-messy-code&quot;&amp;gt;解决invalid byte sequence in GBK&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;21 Apr 2014 &amp;lt;a href=&quot;/2014/04/21/future&quot;&amp;gt;后智能手机时代&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;20 Apr 2014 &amp;lt;a href=&quot;/2014/04/20/githubpages&quot;&amp;gt;GitHub基础入门&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　　　　　   &amp;lt;li&amp;gt;12 Jan 2013 &amp;lt;a href=&quot;/2013/01/12/prime&quot;&amp;gt;js-算出某值以内的质数&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
　　　   　
　  　&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的Yaml文件头表示，首页使用default模板，标题为&quot;我的Blog&quot;。然后，首页使用了 % for post in site.posts %，表示对所有帖子进行一个遍历。这里要注意的是，Liquid模板语言规定，输出内容使用两层大括号，单纯的命令使用一层大括号。至于 site.baseurl 就是_config.yml中设置的baseurl变量。&lt;/p&gt;

&lt;p&gt;目录结构变成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   /jekyll_demo
　　　　   |--　_config.yml
　　　　   |--　_layouts
　　　　   |　　　|--　default.html
　　　   　|--　_posts
　　　   　|　　　|--　2012-08-25-hello-world.html
　　　   　|--　index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;第六步，发布内容。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;现在，这个简单的Blog就可以发布了。先把所有内容加入本地git库。
有了文章以后，还需要有一个首页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   　$ git add .

　　 $ git commit -m &quot;first post&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，前往github的网站，在网站上创建一个名为jekyll_demo的库。接着，再将本地内容推送到github上你刚创建的库。注意，下面命令中的username，要替换成你的username。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ git remote add origin https://github.com/username/jekyll_demo.git

　　 $ git push origin gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上传成功之后，等10分钟左右，访问http://username.github.com/jekyll_demo/就可以看到Blog已经生成了（将username换成你的用户名）。&lt;/p&gt;

&lt;p&gt;首页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082506.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文章页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201208/bg2012082507.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;第七步，绑定域名。&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;如果你不想用 http://username.github.com/jekyll_demo/ 这个域名，可以换成自己的域名。&lt;/p&gt;

&lt;p&gt;具体方法是在repo的根目录下面，新建一个名为 CNAME 的文本文件，里面写入你要绑定的域名，比如 example.com 或者 xxx.example.com。&lt;/p&gt;

&lt;p&gt;如果绑定的是顶级域名，则DNS要新建一条A记录，指向 204.232.175.78。如果绑定的是二级域名，则DNS要新建一条CNAME记录，指向 username.github.com（请将username换成你的用户名）。此外，别忘了将 _config.yml 文件中的 baseurl 改成根目录&quot;/&quot;。&lt;/p&gt;

&lt;p&gt;至此，最简单的Blog就算搭建完成了。进一步的完善，请参考Jekyll创始人的示例库，以及其他用Jekyll搭建的blog。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2015/05/13/jekyll-learn</link>
                <guid>http://yuxiaole.github.io/jekyll/2015/05/13/jekyll-learn</guid>
                <pubDate>2015-05-13T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>收藏颜色</title>
                <description>&lt;h1&gt;收藏颜色的工具&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://enml.github.io/blog/image/collect_color.jpg&quot; alt=&quot;collect_color&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用了三个小时完成了上图的功能，满足了我的需求。&lt;/p&gt;

&lt;p&gt;只要在输入框输入颜色数值，便可记录到数据库，并把颜色作为该数值背景色输出页面。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;本来是在寻找一个可以保存自己喜欢的颜色的工具，一开始想着记录在onenote，但是只能记录数值，不够直观。如果把图片粘贴过去会很繁琐并且不够雅观。后来把颜色直接合并在一张图上，但记录时每次都需要进行图片修改，繁琐也依然不美观。中午午睡后百度了一下是否有相关的在线工具，一无所获。突然想着要不自己搞一个吧！在脑海里构建了一下基本框架后觉得可行，便开始编写代码。花了三个小时总算实现了。&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/05/20/collect_color</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/05/20/collect_color</guid>
                <pubDate>2014-05-20T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Template</title>
                <description>&lt;h1&gt;Template&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;在view里面，我们获取了相关的数据，但我们的目的是将数据呈现出来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.首先我们想到的是直接把数据硬编码到html代码里面，然后通过&lt;code&gt;HttpResponse&lt;/code&gt;对象传递给浏览器进行渲染：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % now
    return HttpResponse(html)
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;但是很明显这种方法不适合生产环境，你不可能把整个html页面都硬编码在view里面，因为这显得既愚蠢又低效。对于template的改动很明显要比view频繁得多，这种方式意味着你想更改页面表现时都必须得改动python代码，并且前后端无法同步开发。于是有了第二种方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.把html代码分离成独立的模板，通过加载模板文件进行渲染，这样可以实现前后端分离：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;   #view
from django.shortcuts import render_to_response
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response(&#39;current_datetime.html&#39;, {&#39;current_date&#39;: now})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#template
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now .&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过render()传递数据给template的方式在上一篇文章有列举出来。这种模式的好处很明显。但我们又遇到一个问题：&lt;strong&gt;假如我的网站有100个页面，那我是不是要写100个template呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道这样是愚蠢。编程中有一个很重要的思想就是--&lt;strong&gt;最大限度地实现代码重用。&lt;/strong&gt; 而我们写100个页面的重复代码可能已经超过40%了，这不但费时费力，你还可能见笑于大方之家。所以我们有一种优雅的解决方式：&lt;strong&gt;include&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1). 把重用代码分离出来，比如header.html,footer.html,sidebar.html；然后&lt;code&gt;include&lt;/code&gt;到content.html中。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# header.html

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # footer.html

        &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# include &#39;header&#39; and &#39;footer&#39;

{ include &#39;header.html&#39; %}
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
{ include &#39;footer.html&#39; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，这样很优雅，可以实现代码重用。但是仍然有个问题：当代码中存在哪怕一个标记不同时，这部分代码你就无法分离出来，这导致了你仍然需要重复大量的代码。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# first page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# second page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Future time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个页面中&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;不同，意味着&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;以下的部分都不能并入&lt;code&gt;header.html&lt;/code&gt;中，哪怕下面仍然存在大量的重复代码。所以有了更优雅的解决办法：&lt;strong&gt;extends&lt;/strong&gt; -- inculde的逆向思维。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2). 我们把模板里面的‘不同代码’进行定义，相同的代码保存为base模板&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{ block title %}{ endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    { block content %}{ endblock %}
    { block footer %}
    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    { endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;base.html&lt;/code&gt;变成了一个骨架，你可以把需要的内容填充进去即可，这最大限度实现了代码重用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # first page

    { extends &quot;base.html&quot; %}

    { block title %}The current time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # second page

    { extends &quot;base.html&quot; %}

    { block title %}Future time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;woo! 简单优雅！这是Template设计的思想历程。&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/05/10/template</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/05/10/template</guid>
                <pubDate>2014-05-10T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>view传递context的方式</title>
                <description>&lt;h1&gt;view传递context的方式&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt; 通过view的render()方法填充template可以有以下方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.适合于数据量小且静态的数据。在template中直接使用相关键值为标签：
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test1(request):
    return render(request,&#39;test/raw.htm&#39;,{
                &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False})
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;2.通过调用属性的方式传递整个dictionary。但在template中必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test2():
    person = {  &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,{ &#39;person&#39;:person, &#39;dict&#39;:dict})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.使用&lt;strong&gt;locals(),locals()&lt;/strong&gt; 是个字典，直接赋值给变量。很明显这种方式更加优雅和便捷，但缺点就是它会把所有的dictionary都传递，也就是说它默认传递的值可能会比你预想中的多。&lt;/p&gt;

&lt;p&gt;   template中仍然必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test3():
    person = {  &#39;name&#39;: &#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,locals())
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/05/03/view_render</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/05/03/view_render</guid>
                <pubDate>2014-05-03T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>install jekyll 流程</title>
                <description>&lt;h1&gt;install jekyll 流程&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载&lt;code&gt;ruby&lt;/code&gt;&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;安装ruby download&lt;/a&gt; ，然后下载&lt;strong&gt;DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe&lt;/strong&gt;。安装完&lt;code&gt;ruby&lt;/code&gt;后，再安装&lt;code&gt;rubyGems&lt;/code&gt;:运行&lt;code&gt;gem update --system&lt;/code&gt;即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压DevKit，然后命令行cd到该目录，运行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;pre&gt;&lt;code&gt; ruby dk.rb init
 ruby dk.rb review 
 ruby dk.rb install
 gem install rdiscount --platform=ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DevKit安装完后，即可安装jekyll：&lt;code&gt;gem install jekyll&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/27/install-jekyll</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/27/install-jekyll</guid>
                <pubDate>2014-04-27T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>python list的技巧</title>
                <description>&lt;h1&gt;Python list的一些技巧&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;列表相邻元素压缩器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; zip(*([iter(a)] * 2))
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::2], a[1::2])
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::3], a[1::3], a[2::3])
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*(a[i::k] for i in range(k)))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;用压缩器反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m.items()
[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]
&amp;gt;&amp;gt;&amp;gt; zip(m.values(), m.keys())
[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]
&amp;gt;&amp;gt;&amp;gt; mi = dict(zip(m.values(), m.keys()))
&amp;gt;&amp;gt;&amp;gt; mi
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表展开&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2], [3, 4], [5, 6]]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain.from_iterable(a))
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; sum(a, [])
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; [x for l in a for x in l]
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; [x for l1 in a for l2 in l1 for x in l2]
[1, 2, 3, 4, 5, 6, 7, 8]

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
&amp;gt;&amp;gt;&amp;gt; flatten(a)
[1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;生成器表达式&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g = (x ** 2 for x in xrange(10))
&amp;gt;&amp;gt;&amp;gt; next(g)
0
&amp;gt;&amp;gt;&amp;gt; next(g)
1
&amp;gt;&amp;gt;&amp;gt; next(g)
4
&amp;gt;&amp;gt;&amp;gt; next(g)
9
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10))
2025
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)
408
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;字典推导&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {x: x ** 2 for x in range(5)}
&amp;gt;&amp;gt;&amp;gt; m
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; m = {x: &#39;A&#39; + str(x) for x in range(10)}
&amp;gt;&amp;gt;&amp;gt; m
{0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用字典推导反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m
{&#39;d&#39;: 4, &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&amp;gt;&amp;gt;&amp;gt; {v: k for k, v in m.items()}
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Point = collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p
Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p.x
1.0
&amp;gt;&amp;gt;&amp;gt; p.y
2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;继承命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Point(collections.namedtuple(&#39;PointBase&#39;, [&#39;x&#39;, &#39;y&#39;])):
...     __slots__ = ()
...     def __add__(self, other):
...             return Point(x=self.x + other.x, y=self.y + other.y)
...
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; q = Point(x=2.0, y=3.0)
&amp;gt;&amp;gt;&amp;gt; p + q
Point(x=3.0, y=5.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有最大长度的双端队列&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; last_three = collections.deque(maxlen=3)
&amp;gt;&amp;gt;&amp;gt; for i in xrange(10):
...     last_three.append(i)
...     print &#39;, &#39;.join(str(x) for x in last_three)
...
0
0, 1
0, 1, 2
1, 2, 3
2, 3, 4
3, 4, 5
4, 5, 6
5, 6, 7
6, 7, 8
7, 8, 9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可排序词典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = dict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
1, 0, 3, 2, 5, 4, 7, 6, 9, 8
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
10, 9, 8, 7, 6, 5, 4, 3, 2, 1
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/25/python-code</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/25/python-code</guid>
                <pubDate>2014-04-25T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>jekyll加载图片的路径问题</title>
                <description>&lt;h1&gt;jekyll加载图片的路径问题&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　一开始使用根目录&lt;code&gt;/assets/…/img/bg.png&lt;/code&gt;的方式，在localhost调试成功，但在github pages失败。
　后来试了一下当前目录方式&lt;code&gt;./img/bg.png&lt;/code&gt;成功。也可以用&lt;code&gt;img/bg.png&lt;/code&gt;表示当前目录。&lt;/p&gt;

&lt;!--break--&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/24/directory</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/24/directory</guid>
                <pubDate>2014-04-24T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>对5天来关于jekyll的心得</title>
                <description>&lt;h1&gt;完成基于jekyll的第一个blog&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　今天差不多把blog完成了，这是我第一个基于jekyll的blog，定制了主题，修改了相关配置，以及解决了中文bug。现在把这5天的心得分享一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先是中文问题，这个困扰我了很久，也花费了不少时间，不过最后总算找到解决办法。给我最大的感触就是，即使碰壁，也得硬着头皮找下去，如果放弃，那就前功尽弃了。&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后是关于bootstrap，因为主题是基于bootstrap，所以这几天对bootstrap也有了深入的了解。Less预编译的思想其实挺方便的，只不过先前习惯了直接div+css的方式后一时难以习惯，但是，习惯是用来打破，不打破那永远都进不了步。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@media通过检测min-width和max-width来进行响应式布局，但要编写全局css时要注意，否则很容易响应不了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\&lt;hr&gt; 添加个具有margin的hr，然后在使用card style时可以通过添加hr来达到分割的效果。另一种方式是直接为card添加一个margin-top。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当我使用中文的categories时，由于permalink中包含categories，导致链接失败。所以只要到_config.yml中修改permalink即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/23/finish-jekyll</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/23/finish-jekyll</guid>
                <pubDate>2014-04-23T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>解决invalid byte sequence in GBK</title>
                <description>&lt;h1&gt;解决invalid byte sequence in GBK&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　jekyll对中文的支持不太好，导致经常出现乱码甚至无法运行&lt;code&gt;jekyll server&lt;/code&gt;命令。解决post内容乱码问题可以通过修改convertible.rb文件的第27行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name), :encoding =&amp;gt; &quot;utf-8&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　原因File.read()可能采用系统默认编码读取文件，中文系统为GBK，但markdown文件均为utf-8编码，所以导致无法正确展现中文。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　但是当我在post.html模板里面加入中文之后，&lt;code&gt;jekyll server&lt;/code&gt;命令直接报错。解决办法是在运行服务器前先运行&lt;code&gt;chcp 65001&lt;/code&gt;命令，即可解决。在官方找到的解决办法&lt;strong&gt;Windows users: run chcp 65001 first to change the command prompt&#39;s character encoding (code page) to UTF-8 so Jekyll runs without errors.&lt;/strong&gt;&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/23/chinese-messy-code</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/23/chinese-messy-code</guid>
                <pubDate>2014-04-23T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>后智能手机时代</title>
                <description>&lt;h1&gt;谁将取代智能手机&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wccbr.com/wp-content/uploads/2013/03/Robot_Wallpaper_1.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能手表&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　现在手表被炒的很热，但以目前来看，手表只是一个辅佐设备；注定手表不可能超越智能手机。手表的特点在于屏幕小，便携，查看信息快速直接；但屏幕小也是它的极限性（屏幕扩大了跟智能手机就没差别了），决定了它不适合发展成独立的终端，你能想象拿着手表刷微博看知乎发邮件吗？&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　除非发展出了超越平面显示的信息展现方式，比如说已经被说烂了的“全息投影”。否则手表永远只能是手机的辅佐设备。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能眼镜&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这货一开始我不看好，谁tm想戴个电池cpu在太阳穴那里，而且带了几年眼镜的我表示对眼镜深痛恶绝啊。后来了解了google glass之后，我发现这货绝对是未来。不，我是说这个方向。&lt;/p&gt;

&lt;p&gt;　为什么智能眼镜有潜力取代智能手机呢？首先，我们从电子设备的发展历程可以看出，任何具有划时代的产品都是通过对人机交互方式进行革新。从命令行跨越到图形界面，从物理按键跨越到触摸，从遥控器跨越到体感声控……再看看手表，再怎么有想象力它始终只是一部小尺寸精简化的手机绑在手上，不管是现在市面上丑陋不堪的炒作产品，还是被寄予厚望的iwatch，都难以在信息展现方式上得到突破；再看看眼镜，信息是直接投射到视网膜上，信息展现方式已经不再局限于屏幕的大小，你眼前的整个视角都是屏幕，甚至可以通过调节投射的焦距而达到调节屏幕的大小，那可想像的空间可就大了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为展现信息独特的视角，眼镜可以覆盖你的整个视角，它可以挡住外来的光线让你完全沉浸在数字光影之中；你可以随时随地享受不亚于甚至超越IMAX的视觉盛宴。是的，我说的不是3D眼镜。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为现实与虚拟的无缝结合，你去超市或者在复杂的商业街寻找餐馆，你不用再打开地图或者大众点评，你眼前就是信息与现实的结合体；如果你用过nokia的city lens，你一定知道我在说什么。你不用再厚着脸皮去找心仪的妹子要联系方式了，只要她在社交网络公开信息，你盯着她看几秒可能就已经加了她的微信或者facebook了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为“所见即所得”，你所能看到的美景都可以收入囊中，不会再因为掏出手机解锁打开相机应用而错过稍众即逝的美景。当然，google glass现在因为这个产生的隐私问题而备受争议。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;……还有很大的想象空间，只是我想不出来了。但是如果做到以上3点，你完全可以抛弃你的智能机了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　以上，并不是空穴来风的天方夜谭，不信，你试着在手表上想象一下。这些是基于信息展现方式，或者说是交互方式的革新。google glass目前并不足以产生颠覆性，产品还不完善，技术也难以突破，生态更是一片荒芜，但它叩开了一个全新世界的大门，这个大门后面的世界才是未来。说实话，我更期待苹果和微软在这方面的突破。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;机器人&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这条路任重而道远，真的要发展出人工智能的话，很可能要对现有的计算机体系、软硬架构、甚至编程思想统统进行颠覆才有可能。但是，100年后每个人身边陪着个高度智能的机器人作助手甚至伴侣应该没什么好争议的。那时候什么手机电脑手表眼镜通通可以扔掉了，人可以真正得到解放，这个随时随地跟着你的机器人就是你最好最强大的电子设备了。你要打电话，你就跟它说帮我call一下奥巴马；你要玩游戏，它转过身来可能后背就是一块触摸屏；你要写代码，哦，那时候应该不用写代码了……&lt;/p&gt;
</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/21/future</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/21/future</guid>
                <pubDate>2014-04-21T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>GitHub基础入门</title>
                <description>&lt;h1&gt;GitHub Pages（像黑客一样写博客）&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;技术&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;是的，之前github的名字其实早已经如雷贯耳，只是我对它望而生畏，始终不敢去触碰它。因为它咋一看上去冷冰冰的，眼之所及，皆为代码；并且又找不到能详细却直观地描述它的理念的教程，所以我始终无从下手。&lt;/p&gt;

&lt;p&gt;终于，两天前看到&lt;strong&gt;Blogging like a hacker&lt;/strong&gt;这篇文章，决定试试搭建一个基于&lt;strong&gt;github pages&lt;/strong&gt;的blog，遂开始尝试。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;首先下载&lt;code&gt;github&lt;/code&gt;的windows客户端，客户端很简约，这个非常值得称赞。客户端登录后会直接跟你github账号进行绑定同步，因此你能直观的看到github上你的项目文件。硬着头皮尝试各种git命令，不求甚解。以前我很讨厌这种不求甚解的状态，当我在阅读一篇教程时总是希望先了解一下基本脉络，当差不多头脑里有个整体框架后再动手，这样的好处就是你知道你每一步是在做什么，成功率也比较高。但并不是每一篇教程或者每一个项目你都能很快地掌握其基本脉络，就像github。很多教程基本就是直接说输入&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;git push origin master&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;之类的，但他没告诉我输入之后能干什么，会发生什么。更没有人告诉我每一次必须先commit message才能提交。所以我只能糊里糊涂地跟着教程走，不过尝试了几遍之后，也就大概理解了脉络。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github为版本控制系统。也就是说，你每一次的提交都会有相关的标记，以便进行回滚和协作。&lt;/li&gt;
&lt;li&gt;对于远程代码，可以通过&lt;code&gt;git clone&lt;/code&gt;语句进行clone，可以clone到本地库，也可以clone到github库中。&lt;/li&gt;
&lt;li&gt;对于本地代码，可以通过&lt;code&gt;git remote set-url&lt;/code&gt;语句绑定到对应的repository；也可以通过客户端里的public推送到github上。&lt;/li&gt;
&lt;li&gt;每一次push前必须先commit -m，客户端里是填写相应的summary。&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2014/04/20/githubpages</link>
                <guid>http://yuxiaole.github.io/jekyll/2014/04/20/githubpages</guid>
                <pubDate>2014-04-20T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>js-算出某值以内的质数</title>
                <description>&lt;h1&gt;js 算出某值以内的质数&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
    //算出 num 以内的所有质数
 
function prime(num){
    var list = [];
    for(var i = 2; i &lt;= num; i++){ list.push(i); } //create a Array
    
    for(var i = 0; i &lt; list.length; i++){
        for(var j = 2; j &lt; list[i]; j++){
            if(list[i] % j == 0){
                list.splice(i,1); //delete the non prime number.it will change the index of other elements
                j = 2; //由于splice导致list[i+1]的index变为i,因此把j置为2以便对list[i+1]进行重新计算
        }
    }
}
&lt;/pre&gt;

</description>
                <link>http://yuxiaole.github.io/jekyll/2013/01/12/prime</link>
                <guid>http://yuxiaole.github.io/jekyll/2013/01/12/prime</guid>
                <pubDate>2013-01-12T00:00:00-08:00</pubDate>
        </item>


</channel>
</rss>
